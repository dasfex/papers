# Geospatial indexing

Огромное количество продуктов, которые мы делаем, так или иначе работают с геоинформацией. Где находится ближайшее кафе? Или точка выдачи заказа? А ближайший водитель такси? Когда речь идёт о хранении информации об объектах на карте и их поиске, мы приходим к geospatial indexing. Такую задачу ещё иногда называют proximity search (буквально поиск ближайшего). 

Посмотрим с вами на общепринятые подходы к решению подобной задачи и попытаемся разобраться, что и где можно заиспользовать из коробки. 

## Straightforward solution

Давайте начнём с уточнения задачи. Пусть наш пользователь хочет найти все бизнесы рамках некоторого радиуса от его местоположения.

> Когда я говорю бизнес, понимаю любое место, где оказывают услуги: магазин, кафе, банк, нотариус, и т.д. Но вообще это может быть что угодно. Люди в сервисе вроде Tinder, курьеры в Лавке или таксист в Uber. 

![Ищем что-то в Минске](https://github.com/user-attachments/assets/36bca7f2-1e38-4fca-9e04-62acf6d22eaa)

Самым простым подходом будет сделать такой запрос:
```sql
SELECT business_id, latitude, longitude
FROM business
WHERE (latitude BETWENN {:my_lat} - radius AND {:my_lat} + radius)
  AND (longitude BETWENN {:my_long} - radius AND {:my_long} + radius)
```

Так мы найдём все нужные бизнесы в пределах bounding box нашего круга. Проблема в том, что такой запрос неэффективен. Нам придётся просканировать всю таблицу в БД и проверить каждый отдельный бизнес на условие. Если ваша табличка содержит десятки-сотни миллионов записей, будет неприятно. 

Можно попробовать улучшить ситуацию и сделать индексы на latitude и longitude колонки. Это сделает чуть лучше, но не прям. 

<img width="822" alt="Ситуация при индексах на широту и долготу" src="https://github.com/user-attachments/assets/d8ea4bee-5b9b-4e63-b114-5d1ec2c4e5fb">

Даже если у вас есть такие индексы, при запросе мы обойдём все бизнесы в мире (!!!) с подходящей долготой и аналогично с широтой. После чего придётся пересекать два множества объектов. На масштабах планеты это может быть долго. Основная проблема здесь в том, что индексы ускоряют поиск в одном измерении, а не двух. Значит надо замапить долготу и широту в одно единственное измерение, чтобы можно было построить индекс поверх этого измерения. 

В нашей задаче есть 2 основных подхода: hash-based и tree-based. 

![Основные подходы к решению нашей задачи](https://github.com/user-attachments/assets/4cd4117f-53ec-4937-ba64-1d83c331dfb1)

Конечно, тут у нас не все известные подходы, а лишь часть примеров. 

Хотя реализации в двух концепциях разные, идея одна и та же: делим карту на небольшие кусочки и строим индекс для быстрого поиска по ним. 

## Hash-based

### Even grid

Even grid -- это когда мы делим планету на равные (в некотором смысле) участки. Каждый участок надо захешировать, после чего по ним можно искать. 

<img width="1182" alt="Делим планету на кусочки" src="https://github.com/user-attachments/assets/47fa03e9-15ec-46cf-8172-6fd2dac61692">

Одна ячейка может содержать много бизнесов, и каждый бизнес принадлежит одной ячейке. Детали реализации опустим в силу большой проблемы у такого подхода: неравномерность расположения объектов: в более густонаселённых городах плотность расположения объектов будет выше, чем в городах поменьше. 

<img width="1170" alt="Разная плотность!" src="https://github.com/user-attachments/assets/62309975-a46b-4fb8-b6a6-9c4784699c8c">

В идеале уметь хранить участки разного размера. Для более плотных кусочков они будут меньше, когда для менее плотных -- больше:

<img width="899" alt="Так что используем разные размеры" src="https://github.com/user-attachments/assets/935f3685-ba69-4ca0-99c8-d61db9006f9a">

Потому сразу идём к geohash.

### Geohash

Идея довольно простая: давайте поделим планету на 4 квадранта. Каждый из них можем описать двумя битами. У двух левых квадрантов первый бит будет 0, а у двух правых -- 1. Аналогично с верхними/нижними, но со вторым битом. 

<img width="976" alt="Geohash basics" src="https://github.com/user-attachments/assets/d7efb50b-1423-4814-9544-33dce1f31073">

Дальше берём интересующий нас квадрант и делим его на 4 квадранта поменьше, следуя правилам хеширования выше. 

<img width="1213" alt="Screenshot 2024-11-04 at 13 49 27" src="https://github.com/user-attachments/assets/6f15679d-3d86-4c7f-a7a2-5cd261ef74a1">

Повторяя такую операцию, мы можем прийти к подходящим для нас размерам. 

> Можно заметить, что порядок обхода подобной структуры это что-то вроде [z-order curves](https://www.wikiwand.com/en/articles/Z-order_curve). Похожий подход [может использоваться в Delta Lake](https://docs.databricks.com/en/delta/data-skipping.html#delta-zorder).
> 
> Тут есть [небольшое видео](https://www.youtube.com/watch?v=X6ugouVuQxk) с визуализацией уточнения геохеша на сфере. 

Посмотрим на пример:

![Часть Минска с geohash](https://github.com/user-attachments/assets/6e0e1b2f-a1e5-4b7b-ae2a-08e2029114c1)

Правый верхний прямоугольник на картиночке геохешом будет записываться как `11110 01001 01110 01101 01101`. После конвертации через base32 получим `u9edd`. И логично, что регулируя длину геохеша, мы можем регулировать точность:

![Точность геохеша](https://github.com/user-attachments/assets/2ad1b74c-7237-4206-a304-ecee67e19df6)

Для практических задач нам достаточно иметь геохеш длиной от 4 до 6. Всё что точнее обычно слишком маленькое, а что больше -- слишком большое. Когда мы имеем радиус, в рамках которого нужно что-то найти, нам достаточно понять, какой длины геохеша достаточно, чтобы покрыть наш круг полностью. Например для радиуса 500 метров нам достаточно длины 6.

Ещё одно приятное свойство: геохеш это просто строка. То есть поиск по нему это набор базовых операций со строками. Нам не нужна отдельная БД для такого (хотя и нужны дополнительные навороты в существующие). 

Но в каждой бочке мёда.. Конечно, есть корнеркейсы. Например, с соседними ячейками. Если 2 геохеша имеют длинный общий префикс, мы можем с уверенностью утверждать, что они рядом. Но обратное неверно. Например вот геохеш какого-то здания в Краснодаре (szgzbpg):

![Здание в Краснодаре](https://github.com/user-attachments/assets/7d056bc3-a896-479a-aad4-edd12f5356ce)

А вот геохеш другой части этого здания (ub5b005):

![То же здание в Краснодаре](https://github.com/user-attachments/assets/0319d5ac-b404-4266-a2c1-afec05cf098b)

Другая проблема -- когда два объекта находятся рядом, но их геохеши отличаются (даже если на 1 символ). Решением тут может быть проверять не только один участок с фиксированным геохешом, но и объекты из всех соседних участков. Вычисление соседних ячеек по геохешу задача несложная и решённая (например, [libgeohash](https://github.com/simplegeo/libgeohash) в примерно 300 строк).

Конечно, любая попытка положить нашу прекрасную планету (неидеальный эллипсоид) на плоскость будет тянуть за собой трейдофы. Можно посмотреть короткий 6-минутный ролик [Why all world maps are wrong](https://www.youtube.com/watch?v=kIID5FDi2JQ).

### Cartesian tiers

Когда яндексишь cartesian tiers, первые ссылки будут про [Solr](https://solr.apache.org). Это такой движок для полнотекстового поиска поверх Lucene. Подразумевается, что текстовые данные могут иметь также и location метаинформацию. И этим можно пользоваться для поиска/скоринга результатов поиска. 

Суть подхода в том, чтобы описать карту мира набором слоёв. Первый, как и геохеш, состоит из 4 квадрантов. Второй слой есть первый, в котором каждый квадрант поделили ещё на 4 (всего 16). И т.д. Для практики, говорят, достаточно 20 слоёв (порядка 10^12 квадрантов на самом нижнем). Все операции происходят так же, как и с геохешом, но учитывая свои детали реализации. Останавливаться тут не будем. 

## Tree-based

### Quadtree

Идея тут такая же: рекурсивно делим карту на 4 части, пока у нас выполняется некоторое условие. Таким условием может являться, например, количество объектов на участке. Так мы не будем делиться слишком глубоко в местах, где у нас мало интересующих нас объектов (небольшие города или океан). 

Это всё-таки дерево, так что можно представить примерно так:

<img width="664" alt="Quadtree example" src="https://github.com/user-attachments/assets/6eb2721e-8692-44eb-8880-fef301de0bbd">

Но более корректно будет представление на плоскости:

![Quadtree example on greed](https://github.com/user-attachments/assets/89297f67-607e-4e42-8368-e56945770c18). 

В дефолтной реализации каждая нода дерева будет хранить координаты для левого верхнего и правого нижнего углов + 4 указателя на детей. И обычно такие индексы всегда in-memory. Это не беда, т.к. даже для большого количества объектов весить индекс будет единицы Гб.

Все нужные операции выполняются аналогично, правда тут вам надо "ходить" по дереву в родителя и искать ноды-сиблинги. Т.к. высота дерева небольшая, это не должно быть очень долго. 

Правда любые операции по изменению локаций объектов могут привести к сильной перебалансировке дерева. 

### R-tree

R-tree хорошо бы использовать, когда ваши объекты это не просто точки, а какие-то более сложные полигоны. В отличие от решений выше, листья в R-tree могут пересекаться по объектам.

![R-tree svg](https://github.com/user-attachments/assets/946ec323-caf9-47f2-94da-4f55b2036f5a)

Не будем глубоко закапываться в реализацию и детали, т.к. подобные вещи легко находятся. Но вот вам [визуализация](https://observablehq.com/@stardisblue/quadtree-vs-rtree) со сравнением двух видов деревьев на потыкаться.

### Google S2

В отличие от других решений, где карта проецируется на плоскость, Google S2 работает с планетой как сферой. Это позволяет сэкономить некоторое количество ресурсов и меньше "врать" из-за трейдофов проекции Земли на плоскость. 

![s2hierarchy](https://github.com/user-attachments/assets/26af13ba-29de-4a7c-85f8-f8e856f8d207)

Тут видим, что края ячеек изогнуты, т.к. применяется как раз сферическая геометрия, которая ближе к реальной ситуации. 

У каждой ячейки есть уровень (от 0 до 30), который говорит о том, как глубоко мы делили мир для получения этой ячейки. Ячейки на последнем, 30м, уровне размера примерно 1см. И их порядка 6 * 4^30. 

> [Тут](http://s2geometry.io/resources/s2cell_statistics) есть табличка с размерами ячеек относительно уровней.

Очевидно, что ячейки нужно как-то занумеровать. В S2 выбран подход, повышающий локальность. Если посмотреть на картинки про z-order curves, то можно заметить, что в какой-то момент для обхода вам нужно перескочить большой участок. Подход в S2 основан на [space-filling curves](https://en.wikipedia.org/wiki/Space-filling_curve). И на сфере он позволяет делает переходы между регионами не очень далеко:

![s2curve-small](https://github.com/user-attachments/assets/1e325457-68b3-4d52-aadd-c3f48e1497ab)

На картиночке у нас покрытие планеты кривой на 5 уровне. С таким способом обхода нумерация ячеек обладает следующим свойством, которого у геохеша нет: если ячейки находятся рядом на карте, то и номера у них будут близкими по значению. А это повышает локальность данных для индексации. 

В противовес Google S2 есть [Uber H3](https://h3geo.org). Тут подразумевается, что планета это не сфера, а икосаэдр (многогранник с 20 гранями), и каждая грань рекурсивно разбивается на гексагоны. 

## Tech stack

Кроме вышеназванных технологий, можно использовать и другие:
- индексы GiST/SP-GiST в Postgres. Это не самостоятельные решения, но вместе с конкретными подходами, которые позволяют задать отношения между объектами (в нашем случае точками на карте), можно решать нужную задачу. Например, пристраивая поверх R-tree.
- [PostGIS](https://postgis.net) расширение к Postgres.
- Redis умеет делать базовые операции из коробки. 

## Fun part

Есть такой замечательный сервис [what3words](https://what3words.com/), который умеет конвертировать любую точку на планете в 3 слова. Например одна из точек, находящаяся примерно на месте офиса Яндекса в Минске может быть закодирована словами [///острый.складка.империя](https://what3words.com/острый.складка.империя).

Как это счастье работает, я не нашёл, но можно предположить, что имея фиксированный размер конечных точек (он порядка 1м^2) можно поделить геохеш на три части, каждая из которых мапится на некоторое слово в словаре. Правда они явно не делят просто на 3 куска, т.к. у двух точек рядом все три слова отличаются, но это можно делать более хитрыми способами. 

----------
1. [ByteByteGo видео](https://www.youtube.com/watch?v=M4lR_Va97cQ) про дизайн сервиса вроде Yelp. Отсюда надёргал часть картинок. 
2. [Geohash online](https://www.geohash.es/encode).
3. [Google S2 geometry](http://s2geometry.io/devguide/s2cell_hierarchy.html).
4. [Пост про гильбертовы кривые в S2](https://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/).
5. [Отличный пост про разные кривые](https://www.pyblog.xyz/spatial-index-space-filling-curve).
