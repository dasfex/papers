# Geospatial indexing

Огромное количество продуктов, которые мы делаем своими руками, так или иначе работает с геоинформацией. Где находится ближайшее кафе? Или точка выдачи заказа? А ближайший водитель такси? Когда речь идёт о хранении информации об объектах на карте и их поиске, мы приходим к geospatial indexing. Такую задачу ещё иногда называют proximity search (буквально поиск ближайшего). 

Посмотрим с вами на общепринятые подходы к решению подобной задачи и попытаемся разобраться, что и где можно заиспользовать из коробки. 

## Straightforward solution

Давайте начнём с уточнения задачи. Пусть наш пользователь хочет найти все бизнесы рамках некоторого радиуса от его местоположения.

> Когда я говорю бизнес, понимаю любое место, где оказывают услуги: магазин, кафе, банк, нотариус, что угодно другое.

![Ищем что-то в Минске](https://github.com/user-attachments/assets/36bca7f2-1e38-4fca-9e04-62acf6d22eaa)

Самым простым подходом будет сделать такой запрос:
```sql
SELECT business_id, latitude, longitude
FROM business
WHERE (latitude BETWENN {:my_lat} - radius AND {:my_lat} + radius)
  AND (longitude BETWENN {:my_long} - radius AND {:my_long} + radius)
```

Так мы найдём все нужные бизнесы в пределах bounding box нашего круга. Проблема в том, что такой запрос неэффективен. Нам придётся просканировать всю таблицу в БД и проверить каждый отдельный бизнес на условие. Если ваша табличка содержит десятки-сотни миллионов записей, будет неприятно. 

Можно попробовать улучшить ситуацию и сделать индексы на latitude и longitude колонки. Это сделает чуть лучше, но не прям. 

<img width="822" alt="Ситуация при индексах на широту и долготу" src="https://github.com/user-attachments/assets/d8ea4bee-5b9b-4e63-b114-5d1ec2c4e5fb">

Даже если у вас есть индексы, при запросе мы обойдём все бизнесы в мире (!!!) с подходящей долготой и аналогично с широтой. После чего придётся пересекать пулы значений. На масштабах планеты это может быть долго. Основная проблема здесь в том, что индексы ускоряют поиск в одном измерении, а не двух. Значит надо замапить долготу и широту в одно единственное измерение, чтобы можно было построить индекс поверх этого измерения. 

В нашей задаче есть 2 основных подхода: hash-based и tree-based. 

![Основные подходы к решению нашей задачи](https://github.com/user-attachments/assets/4cd4117f-53ec-4937-ba64-1d83c331dfb1)

Хотя реализации в двух концепциях разные, идея одна и та же: делим карту на небольшие кусочки и строим индекс для быстрого поиска по ним. 

## Hashing

Давайте поделим наш мир на равные (в некотором смысле) участки. 

<img width="1182" alt="Делим планету на кусочки" src="https://github.com/user-attachments/assets/47fa03e9-15ec-46cf-8172-6fd2dac61692">

Одна ячейка может содержать много бизнесов, и каждый бизнес принадлежит одной ячейке. Конечно, надо не забыть про неравномерность расположения объектов: в более густонаселённых городах плотность расположения объектов будет выше, чем в городах поменьше.

<img width="1170" alt="Разная плотность!" src="https://github.com/user-attachments/assets/62309975-a46b-4fb8-b6a6-9c4784699c8c">

В идеале уметь хранить участки разного размера. Для более плотных кусочков они будут меньше, когда для менее плотных -- больше:

<img width="899" alt="Так что используем разные размеры" src="https://github.com/user-attachments/assets/935f3685-ba69-4ca0-99c8-d61db9006f9a">

### Geohash

Geohash -- имплементация hash-based подхода. 

Идея довольно простая: давайте поделим планету на 4 квадранта. Каждый из них можем описать двумя битами. У двух левых квадрантов первый будет 0, а у двух правых -- 1. Аналогично с верхними/нижними, но со вторым битом. 

<img width="976" alt="Geohash basics" src="https://github.com/user-attachments/assets/d7efb50b-1423-4814-9544-33dce1f31073">














